#!/usr/bin/python
'''
  (C) Copyright 2018-2019 Intel Corporation.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

  GOVERNMENT LICENSE RIGHTS-OPEN SOURCE SOFTWARE
  The Government's rights to use, modify, reproduce, release, perform, display,
  or disclose this software are subject to the terms of the Apache License as
  provided in Contract No. B609815.
  Any reproduction of computer software, computer software documentation, or
  portions thereof marked with this legend must also reproduce the markings.
'''
from __future__ import print_function

import time
import os
import random
import json
import shlex
import subprocess

class CartUtils():
    """CartUtils Class"""

    def create_uri_file(self):
        """ create uri file suitable for orterun """

        path = "./uri"
        unique = random.randint(1, 100000)

        if not os.path.exists(path):
            os.makedirs(path)
        urifile = path + "/urifile" + str(unique)

        return urifile

    def check_process(self, proc):
        """ check if a process is still running"""
        proc.poll()
        procrtn = proc.returncode
        if procrtn is None:
            return True
        return False

    def stop_process(self, proc):
        """ wait for process to terminate """
        i = 60
        procrtn = None
        while i:
            proc.poll()
            procrtn = proc.returncode
            if procrtn is not None:
                break
            else:
                time.sleep(1)
                i = i - 1

        if procrtn is None:
            procrtn = -1
            try:
                proc.terminate()
                proc.wait(2)
            except ProcessLookupError:
                pass
            except Exception:
                proc.kill()

        return procrtn

    def get_env(self, cartobj):
        """ return basic env setting in yaml """
        env_CCSA = cartobj.params.get("env", '/run/env_CRT_CTX_SHARE_ADDR/*/')
        test_name = cartobj.params.get("name", '/run/tests/*/')
        host_cfg = cartobj.params.get("config", '/run/hosts/*/')

        log_dir = "{}-{}-{}-{}".format(env_CCSA, test_name, host_cfg, cartobj.id())
        log_path = os.path.join("testLogs", log_dir)
        log_file = os.path.join(log_path, "output.log")

        log_mask = cartobj.params.get("D_LOG_MASK", '/run/defaultENV/')
        crt_phy_addr = cartobj.params.get("CRT_PHY_ADDR_STR", '/run/defaultENV/')
        ofi_interface = cartobj.params.get("OFI_INTERFACE", '/run/defaultENV/')
        ofi_share_addr = cartobj.params.get("CRT_CTX_SHARE_ADDR", '/run/env_CRT_CTX_SHARE_ADDR/*/')
        ofi_ctx_num = cartobj.params.get("CRT_CTX_NUM", '/run/defaultENV/')

        env = " --output-filename {!s}".format(log_path)
        env += ' -x D_LOG_MASK={!s} -x D_LOG_FILE={!s}' \
                        ' -x CRT_PHY_ADDR_STR={!s}' \
                        ' -x OFI_INTERFACE={!s}' \
                        ' -x CRT_CTX_SHARE_ADDR={!s} -x CRT_CTX_NUM={!s}' \
                            .format(log_mask, log_file, crt_phy_addr, \
                                    ofi_interface, ofi_share_addr, \
                                    ofi_ctx_num)

        if not os.path.exists(log_path):
            os.makedirs(log_path)

        return env

    def build_srv_cmd(self, cartobj, urifile, env):
        srvcmd = ""

        # get paths from the build_vars generated by build
        with open('.build_vars.json') as build_file:
            build_paths = json.load(build_file)

        orterun_bin = os.path.join(build_paths["OMPI_PREFIX"], "bin", "orterun")

        srv_host = cartobj.params.get("server", '/run/hosts/*/')
        srv_hoststr = srv_host[0]

        server = " " + cartobj.params.get("server", '/run/tests/*/')
        srv_arg = " " + cartobj.params.get("srv_arg", '/run/tests/*/')
        srv_env = " " + cartobj.params.get("srv_env", '/run/tests/*/')

        srvcmd = "{} --mca btl self,tcp --report-uri {} -N 1 -H {} ".format(orterun_bin, urifile, srv_hoststr)
        #srvcmd += cartobj.pass_enva
        srvcmd += env
        srvcmd += srv_env
        srvcmd += server
        srvcmd += srv_arg

        return srvcmd

    def build_cli_cmd(self, cartobj, urifile, env):
        clicmd = ""

        # get paths from the build_vars generated by build
        with open('.build_vars.json') as build_file:
            build_paths = json.load(build_file)

        orterun_bin = os.path.join(build_paths["OMPI_PREFIX"], "bin", "orterun")

        cli_host = cartobj.params.get("client", '/run/hosts/*/')
        cli_hoststr = cli_host[0]

        client = " " + cartobj.params.get("client", '/run/tests/*/')
        cli_arg = " " + cartobj.params.get("cli_arg", '/run/tests/*/')
        cli_env = " " + cartobj.params.get("cli_env", '/run/tests/*/')

        clicmd = "{} --mca btl self,tcp --ompi-server file:{} -N 1 -H {} ".format(orterun_bin, urifile, cli_hoststr)
        #clicmd += cartobj.pass_enva
        clicmd += env
        clicmd += cli_env
        clicmd += client
        clicmd += cli_arg

        return clicmd

    def launch_srv_cli(self, cartobj, srvcmd, clicmd):
        """ launches sever in the background and client in the foreground """

        srv_cmd = shlex.split(srvcmd)
        srv_rtn = subprocess.Popen(srv_cmd)

        if srv_rtn is None:
            cartobj.fail("Server launch failed, return code %s" \
                       % srv_rtn.returncode)

        # Verify the server is still running.
        if not self.check_process(srv_rtn):
            procrtn = self.stop_process(srv_rtn)
            cartobj.fail("Server did not launch, return code %s" \
                       % procrtn)

        cli_cmd = shlex.split(clicmd)
        cli_rtn = subprocess.call(cli_cmd)

        srv_rtn = self.stop_process(srv_rtn)

        if cli_rtn or srv_rtn:
            cartobj.fail("Failed, return codes client %d " % cli_rtn + \
                      "server %d" % srv_rtn)

        return 0

